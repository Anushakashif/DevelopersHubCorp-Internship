# -*- coding: utf-8 -*-
"""loanacceptance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FJYydva_aTxsHS7s19X7CA4jAGSv6MXY

## Problem Statement

## Predict which customers like likely to accept a personal loan offer
"""

from sklearn.metrics import f1_score
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, classification_report

df = pd.read_csv("/content/Finance.csv")
df

df.head()

df.info()

df.describe()

df.isnull().sum()*100/len(df)

df.drop('Loan_ID', axis=1, inplace=True)

"""## Missing Values"""

sns.countplot(x = df['Gender'], palette='Set2')

df['Gender'] = df['Gender'].fillna(df['Gender'].mode()[0])

sns.countplot(x = df['Married'], palette='Set2')

df['Married'] = df['Married'].fillna(df['Married'].mode()[0])

sns.countplot(x = df['Dependents'], palette='Set2')

df['Dependents'].value_counts()

df['Dependents'] = df['Dependents'].fillna(df['Dependents'].mode()[0])

sns.countplot(x = df['Self_Employed'], palette='Set2')

df['Self_Employed'] = df['Self_Employed'].fillna(df['Self_Employed'].mode()[0])

df['LoanAmount'] = df['LoanAmount'].fillna(df['LoanAmount'].median())

df['Loan_Amount_Term'] = df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mode()[0])

sns.countplot(x = df['Credit_History'], palette='Set2')

df['Credit_History'] = df['Credit_History'].fillna(df['Credit_History'].mode()[0])

df.isnull().sum()

cat_cols = ['Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Property_Area']

plt.figure(figsize=(15,10))
for i, col in enumerate(cat_cols):
  plt.subplot(3, 3, i + 1)
  sns.countplot(data = df, x = col, hue= "Loan_Status", palette="Set2", order= df[col].value_counts().index)
  plt.title(f"{col} by Loan_Status")

plt.tight_layout()
plt.show()

# Males have a higher loan approval rate than females.
# Married applicants are more likely to get loans approved than unmarried ones.
# Applicants with 0 dependents have the highest loan approvals; approval rate decreases slightly with more dependents.
# Graduates have a higher loan approval rate compared to non-graduates.
# Non-self-employed applicants are more likely to get loans approved than self-employed.
# Loans are approved more in semiurban and urban areas than in rural areas.

sns.countplot(x='Credit_History', hue='Loan_Status', palette='Set2', data=df)
plt.title("Credit History vs Loan Status")
plt.show()

# Applicants with a valid credit history (1.0) are far more likely to have their loan approved

"""## Encoding





"""

df.replace({
    'Loan_Status': {'N': 0, 'Y': 1},
    'Gender': {'Male': 0, 'Female': 1},
    'Education': {'Not Graduate': 0, 'Graduate': 1},
    'Self_Employed': {'No': 0, 'Yes': 1},
    'Married': {'No': 0, 'Yes': 1}
}, inplace=True)

df

"""## Training"""

def train_test_split_and_features(df):
  y = df['Loan_Status']
  X = df.drop(['Loan_Status'], axis=1)
  X = pd.get_dummies(data = X, columns = ['Property_Area', 'Dependents'])
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)
  print(X.head(5))
  print(X.columns)
  features = list(X.columns)
  return X_train, X_test, y_train, y_test, features

X_train, X_test, y_train, y_test, features = train_test_split_and_features(df)

"""## Modeling and Evaluation"""

def fit_and_evaluate_model(X_train, X_test, y_train, y_test):
  random_forest = RandomForestClassifier(random_state=42, max_depth=5, min_samples_split= 0.01, max_features = 0.8, max_samples= 0.8)
  model = random_forest.fit(X_train, y_train)
  random_forest_predict = random_forest.predict(X_test)
  random_forest_conf_matrix = confusion_matrix(y_test, random_forest_predict)
  random_forest_acc_score = accuracy_score(y_test, random_forest_predict)
  print('Confusion matrix')
  print(random_forest_conf_matrix)
  print('\n')
  print('Accuracy of Random Forest:', random_forest_acc_score*100, '\n')
  print('Classification Report')
  print(classification_report(y_test, random_forest_predict))
  return model

model = fit_and_evaluate_model(X_train, X_test, y_train, y_test)